import Foundation
import GRDB

open class Database {
    
    public typealias UniqueStringPairs = [String: String]
    public typealias Completion = ((GRDB.Database) -> Void)
    
    open class var config: Configuration {
        var config = Configuration()
        config.prepareDatabase { (db) in
            db.trace(options: .profile) { (event) in
                guard case let .profile(statement, duration) = event else {
                    return
                }
                if duration > 1 {
                    // Add a trailing linebreak to clear the border of SQL string
                    let message = """
                        Duration: \(duration)s, SQL:
                        \(statement.sql)
                        
                    """
                    Logger.database.info(category: "Trace", message: message)
                }
            }
        }
        config.qos = .userInitiated
        return config
    }
    
    private static let registerErrorLogFunction: () -> Void = {
        struct Error: Swift.Error {
            let code: CInt
            let message: String
        }
        GRDB.Database.logError = { (code, message) in
            switch code.primaryResultCode {
            case .SQLITE_NOTICE:
                // Do not report notices, mostly SQLITE_NOTICE_RECOVER_WAL
                Logger.database.info(category: "DB", message: "code: \(code), message: \(message)\n")
            case .SQLITE_ERROR:
                if message.hasPrefix("no such table: grdb_migrations") {
                    Logger.database.info(category: "DB", message: "code: \(code), message: \(message)\n")
                } else {
                    AppGroupUserDefaults.User.needsRebuildDatabase = true
                    fallthrough
                }
            default:
                // Stupid error from CoreFoundation
                if !message.contains("cfurl_cache_response") {
                    // Reporting is disabled for now. Many of them are generated by iOS system but not Mixin.
                    // Among those Mixin genrated ones, most of them are triggered in Notification Service
                    // because db is locked. Re-enable it after the locking mechanism is resolved.
                    // reporter.report(error: Error(code: code.rawValue, message: message))
                    Logger.database.error(category: "DB", message: "code: \(code), message: \(message)\n")
                }
            }
        }
        return {}
    }()
    
    open var needsMigration: Bool {
        false
    }
    
    let pool: DatabasePool
    
    private let url: URL
    
    public init(url: URL) throws {
        Self.registerErrorLogFunction()
        self.pool = try DatabasePool(path: url.path, configuration: Self.config)
        self.url = url
    }
    
    open func tableDidLose(with error: Error?, fileSize: Int64?, fileCreationDate: Date?) {
        
    }
    
    public func read<Value>(_ reader: (GRDB.Database) throws -> Value) throws -> Value {
        do {
            return try pool.read(reader)
        } catch {
            handleDatabaseError(error)
            throw error
        }
    }
    
    @discardableResult
    public func write(_ updates: (GRDB.Database) throws -> Void) -> Bool {
        do {
            try pool.write(updates)
            return true
        } catch {
            handleDatabaseError(error)
            return false
        }
    }
    
    public func writeAndReturnError<Value>(_ updates: (GRDB.Database) throws -> Value) throws -> Value {
        do {
            return try pool.write(updates)
        } catch {
            handleDatabaseError(error)
            throw error
        }
    }
    
    public func vacuum() throws {
        try pool.vacuum()
    }
    
    public func makeSnapshot() throws -> DatabaseSnapshot {
        try pool.makeSnapshot()
    }
    
    @discardableResult
    public func execute(
        sql: String,
        arguments: StatementArguments = StatementArguments(),
        completion: Completion? = nil
    ) -> Bool {
        write { (db) in
            try db.execute(sql: sql, arguments: arguments)
            if let completion = completion {
                db.afterNextTransaction(onCommit: completion)
            }
        }
    }
    
    // Only use for migration. See comments in *ColumnMigratableTableDefinition*
    internal func migrateTable(
        with table: ColumnMigratable,
        into db: GRDB.Database
    ) throws {
        if try db.tableExists(table.tableName) {
            let existedColumns = try TableInfo.fetchAll(db, sql: "PRAGMA table_info(\(table.tableName.quotedDatabaseIdentifier));")
            let existedColumnNames = Set(existedColumns.map(\.name))
            if let sql = table.alterTableSQL(existedColumnNames: existedColumnNames) {
                try db.execute(sql: sql)
            }
        } else {
            try db.execute(sql: table.createTableSQL())
        }
    }
    
    private func handleDatabaseError(_ error: Error) {
        let isDatabaseLockedInExtension = switch error {
        case GRDB.DatabaseError.SQLITE_BUSY:
            isAppExtension
        default:
            false
        }
        if !isDatabaseLockedInExtension {
            reporter.report(error: error)
        }
        Logger.database.error(category: "Database", message: "\(error)")
        guard let error = error as? GRDB.DatabaseError else {
            return
        }
        guard error.resultCode != .SQLITE_INTERRUPT else {
            return
        }
        guard let message = error.message, message.hasPrefix("no such table:"), !message.hasPrefix("no such table: grdb_migrations") else {
            return
        }
        let attributesError: Error?
        let fileSize: Int64?
        let fileCreationDate: Date?
        do {
            let attributes = try FileManager.default.attributesOfItem(atPath: url.path)
            attributesError = nil
            fileSize = (attributes[.size] as? NSNumber)?.int64Value
            fileCreationDate = attributes[.creationDate] as? Date
        } catch {
            attributesError = error
            fileSize = nil
            fileCreationDate = nil
        }
        tableDidLose(with: attributesError, fileSize: fileSize, fileCreationDate: fileCreationDate)
    }
    
}

// MARK: - Metadata Fetching
extension Database {
    
    public func recordExists<Record: TableRecord>(
        in table: Record.Type,
        where condition: SQLSpecificExpressible
    ) -> Bool {
        try! read { (db) -> Bool in
            try table.select(Column.rowID).filter(condition).fetchOne(db) != nil
        }
    }
    
    public func count<Record: TableRecord>(
        in table: Record.Type,
        where condition: SQLSpecificExpressible? = nil
    ) -> Int {
        try! read { (db) -> Int in
            if let condition = condition {
                return try table.filter(condition).fetchCount(db)
            } else {
                return try table.fetchCount(db)
            }
        }
    }
    
}

// MARK: - Record Fetching
extension Database {
    
    public func selectAll<Record: MixinFetchableRecord & TableRecord>() -> [Record] {
        try! read { (db) -> [Record] in
            try Record.fetchAll(db)
        }
    }
    
    public func select<Value: DatabaseValueConvertible>(
        with sql: String,
        arguments: StatementArguments = StatementArguments()
    ) -> Value? {
        try! read { (db) -> Value? in
            try Value.fetchOne(db, sql: sql, arguments: arguments, adapter: nil)
        }
    }
    
    public func select<Value: DatabaseValueConvertible>(
        with query: GRDB.SQL
    ) -> Value? {
        try! read { (db) -> Value? in
            let (sql, arguments) = try query.build(db)
            return try Value.fetchOne(db, sql: sql, arguments: arguments)
        }
    }
    
    public func select<Value: DatabaseValueConvertible>(
        with sql: String,
        arguments: StatementArguments = StatementArguments()
    ) -> [Value] {
        try! read { (db) -> [Value] in
            let values = try Value?.fetchAll(db, sql: sql, arguments: arguments, adapter: nil)
            return values.compactMap { $0 }
        }
    }
    
    public func selectSet<Value: DatabaseValueConvertible>(
        with sql: String,
        arguments: StatementArguments = StatementArguments()
    ) -> Set<Value> {
        try! read { (db) -> Set<Value> in
            try Value.fetchSet(db, sql: sql, arguments: arguments, adapter: nil)
        }
    }
    
    public func select<Value: DatabaseValueConvertible>(
        with query: GRDB.SQL
    ) -> [Value] {
        try! read { (db) -> [Value] in
            let (sql, arguments) = try query.build(db)
            return try Value.fetchAll(db, sql: sql, arguments: arguments)
        }
    }
    
    public func select<Record: TableRecord, Value: DatabaseValueConvertible>(
        column: Column,
        from table: Record.Type,
        where condition: SQLSpecificExpressible? = nil,
        order orderings: [SQLOrderingTerm]? = nil
    ) -> Value? {
        try! read { (db) -> Value? in
            var request = Record.select([column]).limit(1)
            if let condition = condition {
                request = request.filter(condition)
            }
            if let orderings = orderings {
                request = request.order(orderings)
            }
            return try Value.fetchOne(db, request)
        }
    }
    
    public func select<Record: TableRecord, Value: DatabaseValueConvertible>(
        column: Column,
        from table: Record.Type,
        where condition: SQLSpecificExpressible? = nil,
        order orderings: [SQLOrderingTerm]? = nil,
        offset: Int? = nil,
        limit: Int? = nil
    ) -> [Value] {
        try! read { (db) -> [Value] in
            var request = Record.select([column])
            if let condition = condition {
                request = request.filter(condition)
            }
            if let orderings = orderings {
                request = request.order(orderings)
            }
            if let limit = limit {
                request = request.limit(limit, offset: offset)
            }
            let values = try Value?.fetchAll(db, request)
            return values.compactMap { $0 }
        }
    }
    
    public func select<Table: TableRecord>(
        keyColumn: Column,
        valueColumn: Column,
        from table: Table.Type,
        where condition: SQLSpecificExpressible? = nil,
        order orderings: [SQLOrderingTerm]? = nil,
        offset: Int? = nil,
        limit: Int? = nil
    ) -> UniqueStringPairs {
        try! read { (db) -> UniqueStringPairs in
            var pairs = UniqueStringPairs()
            var request = table.select([keyColumn, valueColumn])
            if let condition = condition {
                request = request.filter(condition)
            }
            if let orderings = orderings {
                request = request.order(orderings)
            }
            if let limit = limit {
                request = request.limit(limit, offset: offset)
            }
            let rows = try Row.fetchCursor(db, request)
            while let row = try rows.next() {
                guard let key: UniqueStringPairs.Key = row[keyColumn.name] else {
                    continue
                }
                pairs[key] = row[valueColumn.name]
            }
            return pairs
        }
    }
    
    public func select<Record: MixinFetchableRecord & TableRecord>(
        where condition: SQLSpecificExpressible,
        order orderings: [SQLOrderingTerm] = []
    ) -> Record? {
        try! read { (db) -> Record? in
            try Record.filter(condition)
                .order(orderings)
                .limit(1)
                .fetchOne(db)
        }
    }
    
    public func select<Record: MixinFetchableRecord & TableRecord>(
        where condition: SQLSpecificExpressible,
        order orderings: [SQLOrderingTerm] = [],
        limit: Int? = nil
    ) -> [Record] {
        try! read { (db) -> [Record] in
            var request = Record.filter(condition)
            if !orderings.isEmpty {
                request = request.order(orderings)
            }
            if let limit = limit {
                request = request.limit(limit)
            }
            return try request.fetchAll(db)
        }
    }
    
    public func select<Record: MixinFetchableRecord>(
        with sql: String,
        arguments: StatementArguments = StatementArguments()
    ) -> Record? {
        try! read { (db) -> Record? in
            try Record.fetchOne(db, sql: sql, arguments: arguments, adapter: nil)
        }
    }
    
    public func select<Record: MixinFetchableRecord>(
        with query: GRDB.SQL
    ) -> Record? {
        try! read { (db) -> Record? in
            let (sql, arguments) = try query.build(db)
            return try Record.fetchOne(db, sql: sql, arguments: arguments)
        }
    }
    
    public func select<Record: MixinFetchableRecord>(
        with sql: String,
        arguments: StatementArguments = StatementArguments()
    ) -> [Record] {
        try! read { (db) -> [Record] in
            try Record.fetchAll(db, sql: sql, arguments: arguments, adapter: nil)
        }
    }
    
    public func select<Record: MixinFetchableRecord>(
        with query: GRDB.SQL
    ) -> [Record] {
        try! read { (db) -> [Record] in
            let (sql, arguments) = try query.build(db)
            return try Record.fetchAll(db, sql: sql, arguments: arguments)
        }
    }
    
}

// MARK: - Record Writing
extension Database {
    
    public func insert<Record: PersistableRecord>(
        _ record: Record,
        onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil,
        completion: Completion? = nil
    ) {
        write { (db) in
            try record.insert(db, onConflict: conflictResolution)
            if let completion = completion {
                db.afterNextTransaction(onCommit: completion)
            }
        }
    }
    
    public func insert<Record: PersistableRecord>(
        _ records: [Record],
        onConflict conflictResolution: GRDB.Database.ConflictResolution? = nil,
        completion: Completion? = nil
    ) {
        guard !records.isEmpty else {
            return
        }
        write { (db) -> Void in
            for record in records {
                try record.save(db, onConflict: conflictResolution)
            }
            if let completion = completion {
                db.afterNextTransaction(onCommit: completion)
            }
        }
    }
    
    // Returns true on success, false on transaction
    @discardableResult
    public func save<Record: PersistableRecord>(
        _ record: Record,
        completion: Completion? = nil
    ) -> Bool {
        write { (db) in
            try record.save(db)
            if let completion = completion {
                db.afterNextTransaction(onCommit: completion)
            }
        }
    }
    
    @discardableResult
    public func save<Record: PersistableRecord>(
        _ records: [Record],
        completion: Completion? = nil
    ) -> Bool {
        guard records.count > 0 else {
            return true
        }
        return write { (db) -> Void in
            try records.save(db)
            if let completion = completion {
                db.afterNextTransaction(onCommit: completion)
            }
        }
    }
    
    // Returns true on success, false on transaction
    @discardableResult
    public func update<Record: PersistableRecord>(
        _ record: Record.Type,
        assignments: [ColumnAssignment],
        where condition: SQLSpecificExpressible,
        completion: Completion? = nil
    ) -> Bool {
        write { (db) in
            try record.filter(condition).updateAll(db, assignments)
            if let completion = completion {
                db.afterNextTransaction(onCommit: completion)
            }
        }
    }
    
}

// MARK: - Record Deletion
extension Database {
    
    @discardableResult
    public func delete<Record: PersistableRecord>(
        _ record: Record.Type,
        where condition: SQLSpecificExpressible,
        completion: Completion? = nil
    ) -> Int {
        do {
            var numberOfChanges = 0
            try writeAndReturnError { (db) -> Void in
                numberOfChanges = try record.filter(condition).deleteAll(db)
                if let completion = completion {
                    db.afterNextTransaction(onCommit: completion)
                }
            }
            return numberOfChanges
        } catch {
            handleDatabaseError(error)
            return 0
        }
    }
    
}
